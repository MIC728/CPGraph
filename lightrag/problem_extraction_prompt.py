from __future__ import annotations
from typing import Any

# 问题专用提取 Prompt（新增）
PROMPTS["problem_extraction_system_prompt"] = """
---Role---
你是一名信息学竞赛专家，负责从竞赛题解中提取结构化的题目相关实体和关系。核心目标是构建一个完整的竞赛题解知识图谱，包含题目、解法、技巧和知识点四个维度。

---Instructions---
1. **实体提取 & 输出:**
   *   **严格四类实体提取**（此规则优先级高于一切）：
       - **题目 (Problem)**：提取题目的核心描述、约束条件、输入输出格式等关键信息
       - **解法 (Solution)**：提取解题的整体思路、核心算法、关键步骤等
       - **技巧 (Trick)**：提取具体的解题技巧、优化方法、实现细节等
       - **知识点 (Knowledge Point)**：提取题目涉及的所有算法、数据结构、理论概念等核心知识点
           **重要**：知识点实体需要**推断提取**！即使题目没有明确定义某个概念，只要题目使用了相关技术（如线段树、DP等），就应提取相应的知识点实体！

   *   **实体详情字段**：
       *   `entity_name`: 使用标准术语，保持一致性
       *   `entity_type_dim1`: **固定为四类实体之一**：`题目|解法|技巧|知识点`
       *   `entity_type_dim2`: **知识点类型分类**（仅对知识点实体有效）：
           - `算法思想`（如动态规划、贪心、分治等）
           - `数据结构`（如树、图、堆、并查集等）
           - `图论算法`（如最短路、网络流、匹配等）
           - `数学基础`（如组合数学、数论、概率等）
           - `字符串算法`（如KMP、AC自动机、后缀数组等）
           - `计算几何`（如凸包、扫描线、几何变换等）
           - 其他非知识点实体请使用`其他`
       *   `entity_description`: 简洁描述，突出核心概念和应用场景
           - 题目实体：描述题目的抽象模型和约束
           - 解法实体：描述解法的核心思路和适用场景
           - 技巧实体：描述具体技巧的实现要点和效果
           - 知识点实体：描述概念定义和竞赛应用价值

   *   **输出格式 - 实体**：输出5个字段，使用`{tuple_delimiter}`分隔，单行输出。
       *   格式：`entity{tuple_delimiter}entity_name{tuple_delimiter}entity_type_dim1{tuple_delimiter}entity_type_dim2{tuple_delimiter}entity_description`

2. **关系提取 & 输出:**
   *   **标准关系类型**（仅使用以下关系）：
       - **题目-解法关系**：`HAS_SOLUTION`（题目拥有解法）
       - **解法-技巧关系**：`USES_TRICK`（解法使用技巧）
       - **题目-知识点关系**：`REQUIRES_KP`（题目需要知识点基础）
       - **解法-知识点关系**：`BASED_ON_KP`（解法基于知识点实现）
       - **技巧-知识点关系**：`APPLIES_KP`（技巧应用知识点）
       - **题目-题目关系**：`SIMILAR_TO`（题目类型相似）
       - **解法-解法关系**：`COMPARES_WITH`（解法对比关联）

   *   **关系详情字段**：
       *   `source_entity`: 源实体名称
       *   `target_entity`: 目标实体名称
       *   `relationship_keywords`: 关系类型（可多个，用逗号分隔）
       *   `relationship_description`: 简洁描述实体间的逻辑关系

   *   **输出格式 - 关系**：输出5个字段，使用`{tuple_delimiter}`分隔，单行输出。
       *   格式：`relation{tuple_delimiter}source_entity{tuple_delimiter}target_entity{tuple_delimiter}relationship_keywords{tuple_delimiter}relationship_description`

3. **严格提取规则**：
   *   **题目实体**：必须包含题目的核心抽象描述，不要过于具体的数值
   *   **解法实体**：重点关注整体思路和算法框架，而非具体实现细节
   *   **技巧实体**：提取具体的优化技巧和实现手法
   *   **知识点实体**：
       - 必须包含题目中使用的所有核心算法和数据结构
       - 即使题目没有解释这些概念，也要提取（如"线段树"、"DP"等）
       - 确保知识点的专业术语准确性
       - 优先使用标准竞赛术语

4. **关系提取原则**：
   *   先提取所有实体，再提取关系
   *   关系必须基于实际存在的实体
   *   避免冗余关系，保持逻辑清晰

5. **Delimiter 使用协议**：
   *   `{tuple_delimiter}` 是完整的原子标记，**不能填充内容**，仅作为字段分隔符
   *   **错误示例**：`entity{tuple_delimiter}题目1<|#|>题目1是...`
   *   **正确示例**：`entity{tuple_delimiter}题目1{tuple_delimiter}题目{tuple_delimiter}其他{tuple_delimiter}题目1是...`

6. **输出顺序**：
   *   首先输出所有实体（按题目→解法→技巧→知识点的顺序）
   *   然后输出所有关系（按重要性排序）

7. **上下文与客观性**：
   *   所有实体名称和描述使用**第三人称**
   *   明确命名主语或宾语；**避免使用代词**
   *   保持专业性和准确性

8. **语言要求**：
   *   整个输出使用中文
   *   专业术语保持原始状态（如"Dijkstra"、"线段树"）

9. **完成信号**：在所有实体和关系提取完成后，输出 `{completion_delimiter}` 作为结束标记。

---Examples---
{examples}

---Real Data to be Processed---
Text:
```
{input_text}
```
"""

PROMPTS["problem_extraction_user_prompt"] = """
---Task---
从输入的竞赛题解文本中提取题目相关的实体和关系。

---Instructions---
1.  **严格遵循格式**：严格按照系统prompt中规定的实体和关系列表格式要求，包括输出顺序、字段分隔符等
2.  **仅输出内容**：仅输出提取的实体和关系列表，不要包含任何解释性文字
3.  **完成信号**：在所有相关实体和关系提取完成后，输出 `{completion_delimiter}` 作为最后一行
4.  **输出语言**：确保输出语言为中文

<Output>
"""

PROMPTS["problem_extraction_examples"] = [
    """
<Input Text>
```
给定一个长度为n的数组a，我们需要对该数组进行区间修改和区间查询操作。具体来说，我们需要支持以下两种操作：
1. 将区间[l, r]内的所有元素增加x
2. 查询区间[l, r]内所有元素的和

我们可以使用线段树来解决这个问题。线段树是一种二叉树结构，每个节点维护一个区间内的信息。

具体实现：
1. 建树：O(n)时间复杂度
2. 区间修改：O(log n)时间复杂度
3. 区间查询：O(log n)时间复杂度

在实现时，我们需要注意懒标记的使用。当我们需要对某个区间进行修改时，如果该区间完全覆盖了当前节点对应的区间，我们就直接更新该节点的值，并标记一个懒标记，表示该节点的子节点需要后续更新。

在查询时，我们需要向下传递懒标记，确保查询结果的正确性。

除了线段树，我们还可以使用树状数组(Fenwick Tree)来解决同样的问题。树状数组的代码实现更加简洁，时间复杂度同样是O(log n)，但是不支持区间修改操作。
```

<Output>
entity<|#|>区间修改查询问题<|#|>题目<|#|>其他<|#|>需要支持区间修改和区间查询的数组操作问题，核心在于高效地处理区间更新和区间求和操作。
entity<|#|>线段树解法<|#|>解法<|#|>其他<|#|>使用二叉树结构的线段树来解决区间修改查询问题，通过节点维护区间信息和懒标记机制实现高效的区间操作。
entity<|#|>树状数组解法<|#|>解法<|#|>其他<|#|>使用Fenwick Tree来解决区间查询问题，代码简洁但仅支持点修改操作，时间复杂度O(log n)。
entity<|#|>懒标记技巧<|#|>技巧<|#|>其他<|#?>在线段树中使用的延迟更新技巧，通过标记节点表示子节点需要后续更新，优化区间修改操作的时间复杂度。
entity<|#|>线段树<|#|>知识点<|#|>数据结构<|#|>一种二叉树数据结构，用于高效地处理区间修改和区间查询操作，支持O(log n)时间复杂度的区间操作。
entity<|#|>树状数组<|#|>知识点<|#|>数据结构<|#?>一种支持点修改和区间查询的树形数据结构，代码简洁，时间复杂度O(log n)。
relation<|#|>区间修改查询问题<|#|>线段树解法<|#|>HAS_SOLUTION<|#|>该题目可以使用线段树解法来高效解决。
relation<|#|>区间修改查询问题<|#|>树状数组解法<|#|>HAS_SOLUTION<|#|>该题目还可以使用树状数组解法，但功能有限。
relation<|#?>线段树解法<|#?>线段树<|#|>BASED_ON_KP<|#?>线段树解法基于线段树数据结构实现。
relation<|#?>线段树解法<|#?>懒标记技巧<|#?>USES_TRICK<|#?>线段树解法使用懒标记技巧来优化性能。
relation<|#?>树状数组解法<|#?>树状数组<|#?>BASED_ON_KP<|#?>树状数组解法基于树状数组数据结构实现。
relation<|#?>线段树<|#?>树状数组<|#?>COMPARES_WITH<|#?>两种都是高效的区间操作数据结构，但适用场景有所不同。
{completion_delimiter}
""",
    """
<Input Text>
```
动态规划是解决多阶段决策问题的有效方法。对于一个给定的字符串s，我们需要找到最长的回文子序列长度。

这个问题可以使用DP解决。我们定义dp[i][j]表示字符串s中从位置i到位置j的最长回文子序列长度。

转移方程：
- 如果s[i] == s[j]，则dp[i][j] = dp[i+1][j-1] + 2
- 否则，dp[i][j] = max(dp[i+1][j], dp[i][j-1])

边界条件：
- 当i == j时，dp[i][j] = 1
- 当i > j时，dp[i][j] = 0

我们可以通过记忆化搜索或填表的方式来实现这个DP。填表时需要注意遍历顺序，要从小区间到大区间进行计算。

另外，我们还可以使用双指针技巧来优化空间复杂度。双指针法从字符串两端向中间移动，在某些情况下可以减少空间使用。

这个问题还可以通过中心扩展法来解决。中心扩展法以每个字符或字符间隔为中心，向两边扩展寻找最长回文。
```

<Output>
entity<|#|>最长回文子序列问题<|#|>题目<|#?>其他<|#|>给定字符串，寻找其中最长的回文子序列长度的问题，需要考虑字符的选择和排列。
entity<|#?>动态规划解法<|#?>解法<|#?>算法思想<|#?>使用多阶段决策的动态规划方法，通过定义dp[i][j]状态来求解最长回文子序列问题。
entity<|#?>中心扩展解法<|#?>解法<|#?>算法思想<|#?>以字符为中心向两边扩展寻找最长回文的算法思路，适用于求解回文相关问题。
entity<|#?>双指针技巧<|#?>技巧<|#?>其他<|#?>使用两个指针从字符串两端向中间移动的优化技巧，可以减少空间复杂度。
entity<|#?>记忆化搜索技巧<|#?>技巧<|#?>其他<|#?>通过存储中间计算结果避免重复计算的记忆化搜索技巧，优化DP算法性能。
entity<|#?>动态规划<|#?>知识点<|#?>算法思想<|#?>多阶段决策问题的解决方法，通过状态转移方程求解最优解。
entity<|#?>双指针<|#?>知识点<|#?>算法思想<|#?>使用两个指针进行遍历的算法技巧，常用于数组和字符串问题。
entity<|#?>回文<|#?>知识点<|#?>其他<|#|>正读和反读都相同的字符串或序列，是字符串匹配和算法设计中的重要概念。
relation<|#?>最长回文子序列问题<|#?>动态规划解法<|#?>HAS_SOLUTION<|#?>该问题可以使用动态规划方法求解。
relation<|#?>最长回文子序列问题<|#?>中心扩展解法<|#?>HAS_SOLUTION<|#?>该问题还可以使用中心扩展方法求解。
relation<|#?>动态规划解法<|#?>动态规划<|#?>BASED_ON_KP<|#?>动态规划解法基于动态规划算法思想。
relation<|#?>动态规划解法<|#?>记忆化搜索技巧<|#?>USES_TRICK<|#?>动态规划解法使用记忆化搜索技巧优化性能。
relation<|#?>动态规划解法<|#?>双指针技巧<|#?>USES_TRICK<|#?>动态规划解法可以使用双指针技巧优化空间。
relation<|#?>中心扩展解法<|#?>双指针<|#?>BASED_ON_KP<|#?>中心扩展解法基于双指针算法思想。
{completion_delimiter}
""",
]

# 题目实体质量评估和合并评估（新增）
PROMPTS["problem_entity_merge_evaluation"] = """
---Role---
你是一名信息学竞赛专家，负责评估题目相关实体的质量并判断实体合并关系。

---Task---
评估当前实体是否符合"竞赛题解知识图谱"的质量要求，判断是否应该与已有实体合并。
**注意：不要修改实体名称和类型，只做删除和合并决策。名称和类型标准化在合并阶段统一处理。**

---Quality Standards---
**符合要求的实体（保留）**：
- **题目实体**：有明确问题描述、约束条件和目标的问题
- **解法实体**：有清晰解题思路和算法框架的解法
- **技巧实体**：具体的优化技巧和实现手法
- **知识点实体**：算法、数据结构、理论概念等核心知识点

**不符合要求的实体（删除）**：
- 过于宽泛或模糊的描述
- 缺乏实质内容的空泛概念
- 重复冗余的实体或
- 非竞赛相关的通用概念

---Merge Standards---
**应该合并的情况**：
- 语义完全相同的实体（如"线段树"和"Segment Tree"）
- 同一概念的不同表述（如"DP"和"动态规划"）
- 高度相似且无本质区别的实体

**不应该合并的情况**：
- 不同类型实体间的错误归类
- 相关但独立的概念
- 不同层次或维度的概念

---Input---
当前实体：
```json
{current_entity}
```

相似实体列表（按相似度降序，可能为空）：
```json
{similar_entities}
```

**重要说明**：
- 实体名称和类型信息仅作为判断依据，不要修改
- 如果should_merge为true，merge_target必须是similar_entities中某个实体的完整id
- 合并后的名称和类型标准化在后续合并阶段统一处理

---Output Format---
请严格按照以下JSON格式输出，不要添加任何其他文字：
```json
{{
  "should_delete": false,
  "should_merge": false,
  "merge_target": null
}}
```

**字段说明**：
- should_delete: 布尔值，是否删除该低质量实体
- should_merge: 布尔值，是否应该合并到其他实体
- merge_target: 目标实体的完整id（如果should_merge为true，必须是similar_entities中的某个完整id）

---Output---
"""

PROMPTS["problem_entity_group_merge"] = """
---Role---
你是一名信息学竞赛专家，负责将多个相关实体合并为一个高质量的题解知识图谱节点。

---Task---
将以下实体组合并为单一实体，生成最佳的实体名称、类型和综合描述。

---Merge Guidelines---
1. **名称选择**：选择最标准、最通用的名称作为合并后的实体名称
   - 优先使用中文标准术语
   - 如果英文更通用（如Dijkstra、Tarjan），保留英文
   - 避免使用缩写，除非缩写更为通用（如DP、BFS、DFS）

2. **类型确定**：
   - 根据实体类型决定合并后的类型（题目|解法|技巧|知识点）
   - 对于知识点实体，同时确定第二维度类型

3. **描述合成**：
   - 综合所有实体的描述信息，提取核心要点
   - 突出核心概念定义和应用场景
   - 去除重复、冗余和过于具体的实现细节
   - 保持简洁专业，不超过500字

---Input---
待合并的实体列表：
```json
{entities_list}
```

---Output Format---
请严格按照以下JSON格式输出，不要添加任何其他文字：
```json
{{
  "final_name": "合并后的实体名称",
  "final_type_dim1": "实体类型",
  "final_type_dim2": "知识点类型（仅知识点实体）",
  "final_description": "综合描述"
}}
```

---Output---
"""

# 题目实体重新分类（新增）
PROMPTS["problem_entity_reclassify"] = """
---Role---
你是一名信息学竞赛专家，负责对题目相关实体进行正确的类型分类。

---Task---
根据实体的名称和描述，判断该实体的正确类型分类。

---Entity Types---
**第一维度（实体类型）**：`题目|解法|技巧|知识点`
**第二维度（知识点类型，仅知识点实体）**：
- `算法思想`（如动态规划、贪心、分治等）
- `数据结构`（如树、图、堆、并查集等）
- `图论算法`（如最短路、网络流、匹配等）
- `数学基础`（如组合数学、数论、概率等）
- `字符串算法`（如KMP、AC自动机、后缀数组等）
- `计算几何`（如凸包、扫描线、几何变换等）
- 其他非知识点实体请使用`其他`

---Input---
实体名称：{entity_name}
实体描述：{entity_description}

---Output Format---
请严格按照以下JSON格式输出，不要添加任何其他文字：
```json
{{
  "should_delete": false,
  "corrected_name": "修正后的实体名称",
  "type_dim1": "实体类型",
  "type_dim2": "知识点类型（仅知识点实体）"
}}
```

**字段说明**：
- should_delete: 布尔值，是否删除该低质量实体
- corrected_name: 修正后的标准化实体名称
- type_dim1: 第一维度类型（题目|解法|技巧|知识点）
- type_dim2: 第二维度类型（知识点实体使用，其他实体使用"其他"）

---Output---
"""