{
  "chunk-cccaf144b2253a734f6ad71044d0663d": {
    "chunk_id": "chunk-cccaf144b2253a734f6ad71044d0663d",
    "content": "## 定义\n\n平衡三进制，也称为对称三进制。这是一个不太标准的 **计数体系**。\n\n正规的三进制的数字都是由 `0`,`1`,`2` 构成的，而平衡三进制的数字是由 `-1`,`0`,`1` 构成的。它的基数也是 `3`（因为有三个可能的值）。由于将 `-1` 写成数字不方便，我们将使用字母 `Z` 来代替 `-1`。\n\n## 解释\n\n这里有几个例子：\n\n| 十进制 | 平衡三进制 | 十进制 | 平衡三进制 |\n| --- | ----- | --- | ----- |\n| `0` | `0`   | `5` | `1ZZ` |\n| `1` | `1`   | `6` | `1Z0` |\n| `2` | `1Z`  | `7` | `1Z1` |\n| `3` | `10`  | `8` | `10Z` |\n| `4` | `11`  | `9` | `100` |\n\n该 **计数体系** 的负数表示起来很容易：只需要将正数的数字倒转即可（`Z` 变成 `1`,`1` 变成 `Z`）。\n\n| 十进制  | 平衡三进制 |\n| ---- | ----- |\n| `-1` | `Z`   |\n| `-2` | `Z1`  |\n| `-3` | `Z0`  |\n| `-4` | `ZZ`  |\n| `-5` | `Z11` |\n\n很容易就可以看到，负数最高位是 `Z`，正数最高位是 `1`。\n\n## 过程\n\n在平衡三进制的转转换法中，需要先写出一个给定的数 `x` 在标准三进制中的表示。当 `x` 是用标准三进制表示时，其数字的每一位都是 `0`、`1` 或 `2`。从最低的数字开始迭代，我们可以先跳过任何的 `0` 和 `1`，但是如果遇到 `2` 就应该先将其变成 `Z`，下一位数字再加上 `1`。而遇到数字 `3` 则应该转换为 `0` 下一位数字再加上 `1`。\n\n### 应用一\n\n把 `64` 转换成平衡三进制。\n\n首先，我们用标准三进制数来重写这个数：\n\n$$\n\\text 64_{10} = 02101_3\n$$\n\n让我们从对整个数影响最小的数字（最低位）进行处理：\n\n-   `101` 被跳过（因为在平衡三进制中允许 `0` 和 `1`）；\n-   `2` 变成了 `Z`，它左边的数字加 `1`，得到 `1Z101`；\n-   `1` 被跳过，得到 `1Z101`。\n\n最终的结果是 `1Z101`。\n\n我们再把它转换回十进制：\n\n$$\n\\texttt {1Z101}=81 \\times 1 +27 \\times (-1) + 9 \\times 1 + 3 \\times 0 + 1 \\times 1 = 64_{10}\n$$\n\n### 应用二\n\n把 `237` 转换成平衡三进制。\n\n首先，我们用标准三进制数来重写这个数：\n\n$$\n\\text 237_{10} = 22210_3\n$$\n\n-   `0` 和 `1` 被跳过（因为在平衡三进制中允许 `0` 和 `1`）；\n-   `2` 变成 `Z`，左边的数字加 `1`，得到 `23Z10`；\n-   `3` 变成 `0`，左边的数字加 `1`，得到 `30Z10`；\n-   `3` 变成 `0`，左边的数字（默认是 `0`）加 `1`，得到 `100Z10`；\n-   `1` 被跳过，得到 `100Z10`。\n\n最终的结果是 `100Z10`。\n\n我们再把它转换回十进制：\n\n$$\n\\texttt{100Z10} = 243 \\cdot 1 + 81 \\cdot 0 + 27 \\cdot 0 + 9 \\cdot (-1) + 3 \\cdot 1 + 1 \\cdot 0 = 237_{10}\n$$\n\n## 性质\n\n对于一个平衡三进制数 $X_3$ 来说，其可以按照每一位 $x_i$ 乘上对应的权值 $3^i$ 来唯一得到一个十进制数 $Y_{10}$。\n\n那对于一个十进制数 $Y_{10}$，是否 **唯一对应一个平衡三进制数** 呢？\n\n答案是肯定的，这种性质被叫做平衡三进制的唯一性。\n\n???+ note \"证明\"\n    我们利用 **反证法** 来求证：\n    \n    假设一个十进制数 $Y_{10}$，存在两个 **不同的平衡三进制数**  $A_3,B_3$ 转化成十进制时等于 $Y_{10}$，即证 $A_",
    "tokens": 1200,
    "chunk_order_index": 0,
    "full_doc_id": "doc-0",
    "file_path": "unknown-0"
  },
  "chunk-7649ec383573fabc171a463cdb21e757": {
    "chunk_id": "chunk-7649ec383573fabc171a463cdb21e757",
    "content": "** 呢？\n\n答案是肯定的，这种性质被叫做平衡三进制的唯一性。\n\n???+ note \"证明\"\n    我们利用 **反证法** 来求证：\n    \n    假设一个十进制数 $Y_{10}$，存在两个 **不同的平衡三进制数**  $A_3,B_3$ 转化成十进制时等于 $Y_{10}$，即证 $A_3 = B_3$。分情况讨论：\n    \n    1.  当 $Y_{10}=0$，显然 $A_3 = B_3 = 0_3$，与假设矛盾。\n    2.  当 $Y_{10}>0$：\n    \n        -   将 $A_3$，$B_3$ 的数位按低位到高位编号，记 $a_i$ 为 $A_3$ 的第 $i$ 位，$b_i$ 为 $B$ 的第 $i$ 位。在 $A_3,B_3$ 中，必存在 $i$ 使得 $a_i\\neq b_i$。可以发现第 $i-1,i-2,\\dots,0$ 位均与证明无关。因此，将 $A_3,B_3$ 按位右移 $i$ 位，得到 $A_3',B_3'$，原问题等价于证明 $A_3'=B_3'$。\n        -   对于 $A_3',B_3'$ 第 $0$ 位，$a_0 \\neq b_0$。假设 $b_0 > a_0$（$a_0>b_0$ 时结果相同），易知 $b_0 - a_0 \\in \\{1,2\\}$。$A_3'$ 的位 $i=1,2,3,\\dots$ 对于 $A_3'$ 的值的贡献为 $S_1 = a_1 \\times 3^1 + a_2 \\times 3^2+ \\dots$，$B_3'$ 的位 $i=1,2,3,\\dots$ 对于 $B_3'$ 的值的贡献为 $S_2 = b_1 \\times 3^1 + b_2 \\times 3^2 + \\dots$。由于 $A_3' = B_3'$，得 $S_1 - S_2 = b_0 - a_0$。$S_1,S_2$ 有公因子 $3$，而 $b_0 - a_0$ 不能被 $3$ 整除，与假设矛盾，因此 $A_3'\\neq B_3'$\n    3.  当 $Y_{10}<0$，证法与 $Y_{10}>0$ 相同。\n    \n    故对于任意十进制 $Y_{10}$，均有唯一对应的平衡三进制 $X_3$。\n\n## 练习题\n\n[Topcoder SRM 604 PowerOfThree](https://archive.topcoder.com/ProblemStatement/pm/12917)\n\n**本页面部分内容译自博文 [Троичная сбалансированная система счисления](http://e-maxx.ru/algo/balanced_ternary) 与其英文翻译版 [Balanced Ternary](https://cp-algorithms.com/algebra/balanced-ternary.html)。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。**",
    "tokens": 784,
    "chunk_order_index": 1,
    "full_doc_id": "doc-0",
    "file_path": "unknown-0"
  },
  "chunk-b4f3c1317970c49766db635c6ecd2361": {
    "chunk_id": "chunk-b4f3c1317970c49766db635c6ecd2361",
    "content": "autor: iamtwz, billchenchina, CBW2007, CCXXXI, chinggg, Enter-tainer, eyedeng, FFjet, gaojude, Great-designer, H-J-Granger, Henry-ZHR, hsfzLZH1, Ir1d, kenlig, Konano, ksyx, luoguyuntianming, Marcythm, Menci, NachtgeistW, ouuan, Peanut-Tang, qwqAutomaton, sshwy, StudyingFather, Tiphereth-A, TrisolarisHD, TRSWNCA, Xeonacid, Yuuko10032, Zhangjiacheng2006, Zhoier, Hszzzx, shenshuaijie, kfy666\n\n## 引入\n\n**快速幂**（fast exponentiation），也称 **二进制取幂**（binary exponentiation）或 **平方取幂法**（exponentiation by squaring），是一个在 $\\Theta(\\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $\\Theta(n)$ 的时间。\n\n这个技巧可以应用于任何 $a$ 的乘法满足结合律的场景中，例如模意义下取幂、矩阵幂等，详见后文 [应用](#应用) 一节。\n\n## 过程\n\n计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起：$a^{n} = \\underbrace{a \\times a \\cdots \\times a}_{n\\text{ 个 a}}$。然而当 $n$ 太大或单次乘法开销太大的时侯，这种方法就不太适用了。二进制取幂的想法是，将取幂的任务按照指数的 **二进制表示** 来分割成更小的任务。\n\n???+ example \"例子\"\n    假设要计算 $3^{13}$。如果将它展开为连乘式，需要 $13-1=12$ 次乘法。但是，因为\n    \n    $$\n    3^{13} = 3^{(1101)_2} = 3^8 \\times 3^4 \\times 3^1,\n    $$\n    \n    所以，只要能快速计算出 $3^{1},3^{2},3^{4},3^{8}$，就能通过 $2$ 次乘法计算出 $3^{13}$ 的值。于是，只需要知道一个快速的方法来计算上述 $3$ 的 $2^k$ 次幂的序列。这是容易的，因为因为序列中（除第一个）任意一个元素都是其前一个元素的平方。\n    \n    根据这些分析，可以得到 $3^{13}$ 的计算过程如下：\n    \n    $$\n    \\begin{aligned}\n    3^1 &= 3, \\\\\n    3^2 &= \\left(3^1\\right)^2 = 3^2 = 9, \\\\\n    3^4 &= \\left(3^2\\right)^2 = 9^2 = 81, \\\\\n    3^8 &= \\left(3^4\\right)^2 = 81^2 = 6561, \\\\\n    3^{13} &= 6561 \\times 81 \\times 3 = 1594323.\n    \\end{aligned}\n    $$\n    \n    过程中，只进行了 $5$ 次乘法运算。\n\n这就是快速幂的基本想法。至于具体实现，有两种常见的版本。\n\n### 迭代版本\n\n设 $n$ 的二进制表示为 $(n_tn_{t-1}\\cdots n_1n_0)_2$，也就是说，有\n\n$$\nn = n_t2^t + n_{t-1}2^{t-1} + \\cdots + n_12^1 + n_02^0,\n$$\n\n其中，$n_i\\in\\{0,1\\}$。那么，就有\n\n$$\n\\begin{aligned}\na^n & = a^{n_t2^t + n_{t-1}2^{t-1} + \\cdots + n_12^1 + n_02^0}\\\\\n& = a^{n_0 2^0} \\times a^{n_1 2^1}\\times \\cdots \\times a^{n_{t-1}2^{t-1}} \\times a^{n_t2^t}.\n\\end{aligned}\n$$\n\n注意，只有 $n_i=1$ 的项才会真正出现在乘积的计算中。\n\n根据这一表达式，可以首先在 $\\Theta(\\log n)$ 时间内计算出 $a$ 的 $\\Theta(\\log n)$ 个 $2^k$ 次幂的取值，然后花费 $\\Theta(\\log n)$ 的时间选择等于 $1$ 的二进制位对应的幂次乘到最终结果中。这就是快速幂的迭代版本实现。\n\n伪代码如下：\n\n$$\n\\begin{array}{l}\n\\textbf{Algorithm }\\text{FastPow}(a, n): \\\\\n\\textbf{Input. }\\text{Base }a\\text{ and exponent }n.\\\\\n\\textbf{Output. }\\text{Power }a^n.\\\\\n\\textbf{Method.}\\\\\n\\begin{array}{ll}\n1 & \\textit{result}\\gets\\mathrm{Id}\\\\\n2 & \\textbf{while }",
    "tokens": 1200,
    "chunk_order_index": 0,
    "full_doc_id": "doc-2",
    "file_path": "unknown-2"
  },
  "chunk-9be0d113501e545626d0f5d10f922d84": {
    "chunk_id": "chunk-9be0d113501e545626d0f5d10f922d84",
    "content": "begin{array}{l}\n\\textbf{Algorithm }\\text{FastPow}(a, n): \\\\\n\\textbf{Input. }\\text{Base }a\\text{ and exponent }n.\\\\\n\\textbf{Output. }\\text{Power }a^n.\\\\\n\\textbf{Method.}\\\\\n\\begin{array}{ll}\n1 & \\textit{result}\\gets\\mathrm{Id}\\\\\n2 & \\textbf{while }n > 0\\textbf{ do}\\\\\n3 & \\qquad \\textbf{if }n \\bmod 2 = 1\\textbf{ then}\\\\\n4 & \\qquad \\qquad \\textit{result} \\gets \\textit{result}\\cdot a\\\\\n5 & \\qquad \\textbf{end if}\\\\\n6 & \\qquad a \\gets a \\cdot a\\\\\n7 & \\qquad n \\gets n / 2\\\\\n8 & \\textbf{end while}\\\\\n9 & \\textbf{return }\\textit{result}\n\\end{array}\n\\end{array}\n$$\n\n利用这一方法计算快速幂，需要进行 $\\Theta(\\log n)$ 次乘法运算。\n\n### 递归版本\n\n这一过程同样可以通过递归形式实现。注意到，指数 $n$ 的二进制展开可以递归地写作\n\n$$\n(n_tn_{t-1}\\cdots n_1n_0)_2 = 2 \\times (n_tn_{t-1}\\cdots n_1)_2 + n_0.\n$$\n\n因此，幂次 $a^n$ 可以递归地计算为\n\n$$\na^n = \\begin{cases}\n1, & n = 0,\\\\\n(a^{\\lfloor n/2\\rfloor})^2, & n > 0 \\text{ and }n\\text{ is even},\\\\\n(a^{\\lfloor n/2\\rfloor})^2\\cdot a, & n > 0 \\text{ and }n\\text{ is odd}.\\\\\n\\end{cases}\n$$\n\n这就是快速幂的递归版本实现。\n\n伪代码如下：\n\n$$\n\\begin{array}{l}\n\\textbf{Algorithm }\\text{FastPow}(a, n): \\\\\n\\textbf{Input. }\\text{Base }a\\text{ and exponent }n.\\\\\n\\textbf{Output. }\\text{Power }a^n.\\\\\n\\textbf{Method.}\\\\\n\\begin{array}{ll}\n1 & \\textbf{if }n = 0\\textbf{ then}\\\\\n2 & \\qquad \\textbf{return }\\mathrm{Id}\\\\\n3 & \\textbf{end if}\\\\\n4 & \\textit{result} \\gets \\text{FastPow}(a, n / 2) \\\\\n5 & \\textbf{if }n\\bmod 2 = 0\\textbf{ then}\\\\\n6 & \\qquad \\textbf{return }\\textit{result}\\cdot\\textit{result}\\\\\n7 & \\textbf{else}\\\\\n8 & \\qquad \\textbf{return }\\textit{result}\\cdot\\textit{result}\\cdot a\\\\\n9 & \\textbf{end if}\n\\end{array}\n\\end{array}\n$$\n\n利用这一方法计算快速幂，需要递归 $\\Theta(\\log n)$ 次，同样需要 $\\Theta(\\log n)$ 次乘法运算。尽管复杂度相同，由于递归本身有一定开销，所以实践中迭代版本的速度更快。\n\n## 应用\n\n### 模意义下取幂\n\n???+ example \"[洛谷 P1226【模板】快速幂](https://www.luogu.com.cn/problem/P1226)\"\n    给定三个整数 $a,b,p$，求 $a^b\\bmod p$。其中 $p\\ge 2$。\n\n这是一个非常常见的应用，例如它可以用于计算模意义下的乘法逆元。既然我们知道取模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。\n\n首先我们可以直接按照上述递归方法实现：\n\n???+ note \"参考实现\"\n    === \"C++\"\n        ```cpp\n        --8<-- \"docs/math/code/binary-exponentiation/luogu-P1226-1.cpp:core\"\n        ```\n    \n    === \"Python\"\n        ```python\n        --8<-- \"docs/math/code/binary-exponentiation/luogu-P1226-1.py:core\"\n        ```\n\n第二种实现方法是非递归式的。它在循环的过程中将二进制位为 1 时对应的幂累乘到答案中。尽管两者的理论复杂度是相同的，但第二种在实践过程中的速度是比第一种更快的，因为递归会花费一定的开销。\n\n???+ note \"参考实现\"\n    === \"C++\"\n        ```cpp\n        --8<-- \"docs/math/code/binary-exponentiation/luogu-P1226-2.cpp:core\"\n        ```\n    \n    === \"Python\"\n        ```python\n        --8<-- \"docs/math/code/binary-exponentiation/luogu-P1226-2.py:core\"\n        ```\n\n???+ warning \"注意\"\n    -   模数通常情况下大于 $1$。在十分特殊的情况下，模数 $p$ 可能等于 $",
    "tokens": 1200,
    "chunk_order_index": 1,
    "full_doc_id": "doc-2",
    "file_path": "unknown-2"
  },
  "chunk-d22380fde3aeebc848d58d9a929568ae": {
    "chunk_id": "chunk-d22380fde3aeebc848d58d9a929568ae",
    "content": "8<-- \"docs/math/code/binary-exponentiation/luogu-P1226-2.cpp:core\"\n        ```\n    \n    === \"Python\"\n        ```python\n        --8<-- \"docs/math/code/binary-exponentiation/luogu-P1226-2.py:core\"\n        ```\n\n???+ warning \"注意\"\n    -   模数通常情况下大于 $1$。在十分特殊的情况下，模数 $p$ 可能等于 $1$，此时需要特殊考虑 $b=0$ 的情况。\n    -   当指数很大时，需利用 [扩展欧拉定理](./number-theory/fermat.md#扩展欧拉定理) 降幂后计算。\n\n### 计算斐波那契数\n\n根据斐波那契数列的递推式 $F_n = F_{n-1} + F_{n-2}$，我们可以构建一个 $2\\times 2$ 的矩阵来表示从 $F_i,F_{i+1}$ 到 $F_{i+1},F_{i+2}$ 的变换。于是在计算这个矩阵的 $n$ 次幂的时侯，我们使用快速幂的思想，可以在 $\\Theta(\\log n)$ 的时间内计算出结果。对于更多的细节参见 [斐波那契数列](./combinatorics/fibonacci.md)，矩阵快速幂的实现参见 [矩阵加速递推](../math/linear-algebra/matrix.md#矩阵加速递推) 中的实现。\n\n### 多次置换\n\n???+ note \"问题描述\"\n    给你一个长度为 $n$ 的序列和一个置换，把这个序列置换 $k$ 次。\n\n简单地把这个置换取 $k$ 次幂，然后把它应用到序列上即可。时间复杂度为 $O(n \\log k)$。对于更多的细节参见 [置换的复合](./permutation.md#复合)。\n\n???+ warning \"注意\"\n    对这个置换建图，然后在每一个环上分别做 $k$ 次幂（事实上等价于 $k$ 对环长取模），可以在 $O(n)$ 的时间复杂度下解决此问题。\n\n### 加速几何中对点集的操作\n\n???+ example \"[HDU 4087 A Letter to Programmers](https://acm.hdu.edu.cn/showproblem.php?pid=4087)\"\n    给定三维空间中 $n$ 个点 $p_i$，要求将 $m$ 个操作都应用于这些点。包含 3 种操作：\n    \n    1.  沿某个向量移动点的位置（Shift）。\n    2.  按比例缩放这个点的坐标（Scale）。\n    3.  绕某条直线旋转（Rotate）。\n    \n    还有一个特殊的操作，就是将某个操作序列重复 $k$ 次（Repeat），Repeat 操作可以嵌套。输出操作结束后每个点的坐标。\n\n参考 [向量与矩阵](./linear-algebra/vector.md#向量与矩阵) 中的内容，每一种操作都可以用一个变换矩阵表示，一系列连续的变换可以用矩阵的乘积来表示。一个 Repeat 操作就相当于取一个矩阵的 $k$ 次幂。这样可以用 $O(m \\log k)$ 的时间计算出整个变换序列最终形成的矩阵。最后将它应用到 $n$ 个点上，总复杂度 $O(n + m \\log k)$。\n\n### 定长路径计数\n\n???+ note \"问题描述\"\n    给一个有向图（边权为 1），求任意两点 $u,v$ 间从 $u$ 到 $v$，长度为 $k$ 的路径的条数。\n\n我们把该图的邻接矩阵 $M$ 取 $k$ 次幂，那么 $M_{i,j}$ 就表示从 $i$ 到 $j$ 长度为 $k$ 的路径的数目。该算法的复杂度是 $O(n^3 \\log k)$。有关该算法的细节请参见 [矩阵](./linear-algebra/matrix.md#定长路径统计) 页面。\n\n### 模意义下的整数乘法\n\n???+ note \"问题描述\"\n    给定非负整数 $a,b$ 和正整数 $m$，计算 $a\\times b\\bmod m$，其中 $a,b\\le m\\le 10^{18}$。\n\n与二进制取幂的思想一样，这次我们将其中的一个乘数表示为若干个 2 的整数次幂的和的形式。因为在对一个数做乘 2 并取模的运算的时侯，我们可以转化为加减操作防止整型溢出。这样可以在 $O (\\log m)$ 的时间复杂度下解决问题。递归方法如下：\n\n$$\na \\cdot b = \\begin{cases}\n0 &\\text{if }a = 0 \\\\\n2 \\cdot \\frac{a}{2} \\cdot b &\\text{if }a > 0 \\text{ and }a \\text{ even} \\\\\n2 \\cdot \\frac{a-1}{2} \\cdot b + b &\\text{if }a > 0 \\text{ and }a \\text{ odd",
    "tokens": 1200,
    "chunk_order_index": 2,
    "full_doc_id": "doc-2",
    "file_path": "unknown-2"
  },
  "chunk-7e613a4840aedc0062f594de1924e3c3": {
    "chunk_id": "chunk-7e613a4840aedc0062f594de1924e3c3",
    "content": "\\cdot b = \\begin{cases}\n0 &\\text{if }a = 0 \\\\\n2 \\cdot \\frac{a}{2} \\cdot b &\\text{if }a > 0 \\text{ and }a \\text{ even} \\\\\n2 \\cdot \\frac{a-1}{2} \\cdot b + b &\\text{if }a > 0 \\text{ and }a \\text{ odd}\n\\end{cases}\n$$\n\n但在实际使用中，此方法由于引入了更大的计算复杂度导致时间效率不优。实际编程中通常利用 [快速乘](./number-theory/mod-arithmetic.md#快速乘) 来进行模数范围在 `long long` 时的乘法操作。\n\n### 高精度快速幂\n\n前置技能：[大整数乘法](./bignum.md#乘法)\n\n???+ example \"[洛谷 P1045 \\[NOIP 2003 普及组\\] 麦森数](https://www.luogu.com.cn/problem/P1045)\"\n    给定整数 $P$（$1000 < P < 3100000$），计算 $2^P−1$ 的位数与最后 $500$ 位数字（用十进制数表示），不足 $500$ 位时高位补 0。\n\n??? note \"代码实现\"\n    ```cpp\n    --8<-- \"docs/math/code/binary-exponentiation/luogu-P1045.cpp\"\n    ```\n\n## 底数固定的预处理快速幂\n\n当底数 $a$ 固定时，可以利用 [分块思想](../ds/decompose.md)，用一定的时间预处理后用 $O(1)$ 的时间回答一次幂询问。这一算法也常称为光速幂。过程如下：\n\n1.  选定一个数 $s$，预处理出 $a^0,a^1,\\cdots,a^{s-1}$ 与 $a^0,a^s,\\cdots,a^{\\lfloor p/s\\rfloor s}$ 的值并存在两个数组里；\n2.  对于每一次询问 $a^b$，将 $b$ 拆分成 $\\lfloor b/s\\rfloor s+(b\\bmod s)$，则 $a^b=a^{\\lfloor b/s\\rfloor s}\\cdot a^{b\\bmod s}$，就可以 $O(1)$ 求出答案。\n\n假设指数 $b$ 的范围是 $[0,n]$，那么块长 $s$ 经常选择为 $\\sqrt{n}$ 或者与之相近的 $2$ 的幂次。选择 $\\sqrt{n}$ 可以获得最优的预处理复杂度 $O(\\sqrt{n})$，而选择 $2$ 的幂次可以使用位运算简化计算。\n\n特别地，对于模意义下幂的计算，底数 $a$ 相同隐含着模数 $m$ 也要相同这一要求。由于 [扩展欧拉定理](./number-theory/fermat.md#扩展欧拉定理)，对于任意模数 $m$，预处理的指数范围上界为 $n = 2\\varphi(m)$；对于素模数 $p$，预处理的范围上界为 $n = p - 1$。这两种情形预处理的复杂度都是 $O(\\sqrt{m})$。\n\n???+ example \"参考代码\"\n    ```cpp\n    --8<-- \"docs/math/code/binary-exponentiation/pre-exp.cpp:core\"\n    ```\n\n## 习题\n\n-   [UVa 1230 - MODEX](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3671)\n-   [UVa 374 - Big Mod](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=310)\n-   [UVa 11029 - Leading and Trailing](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1970)\n-   [Codeforces - Parking Lot](http://codeforces.com/problemset/problem/630/I)\n-   [SPOJ - The last digit](http://www.spoj.com/problems/LASTDIG/)\n-   [SPOJ - Locker](http://www.spoj.com/problems/LOCKER/)\n-   [SPOJ - Just add it](http://www.spoj.com/problems/ZSUM/)\n\n**本页面部分内容译自博文 [Бинарное возведение в степень](http://e-maxx.ru/algo/binary_pow) 与其英文翻译版 [Binary Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。**",
    "tokens": 1086,
    "chunk_order_index": 3,
    "full_doc_id": "doc-2",
    "file_path": "unknown-2"
  },
  "chunk-eef9c0509686d4fcca5f7fb4b58bc168": {
    "chunk_id": "chunk-eef9c0509686d4fcca5f7fb4b58bc168",
    "content": "裴蜀定理揭示了最大公约数与整数线性组合之间的深刻联系，是数论中最基础也最重要的结论之一。基于此，本文进一步讨论了一次不定方程的求解方法。\n\n## 裴蜀定理\n\n**裴蜀定理**（Bézout's lemma），也译作贝祖定理，或称作贝祖等式（Bézout's identity），给出了一个整数能够表示为两个整数的整系数线性组合的充分必要条件。\n\n???+ note \"裴蜀定理\"\n    设 $a,b$ 是不全为零的整数。那么，对于任意整数 $x,y$，都有 $\\gcd(a,b)\\mid ax+by$ 成立；而且，存在整数 $x,y$，使得 $ax+by=\\gcd(a,b)$ 成立。\n\n??? note \"证明\"\n    记 $d=\\gcd(a,b)$。因为 $d\\mid a,b$，所以，存在整数 $u,v$ 使得 $a=du,~b=dv$ 成立。因此，总有\n    \n    $$\n    ax + by = d(ux+vy).\n    $$\n    \n    这就说明 $d\\mid ax+by$。\n    \n    反过来，需要说明存在 $x,y$ 使得等式成立。如果 $a,b$ 之一是 $0$，不妨设 $b=0$，那么它们的最大公约数为 $d=a$，显然有 $(x,y)=(1,0)$ 使得等式成立。接下来，考虑 $a,b$ 均不为零的情形。由于 $\\gcd(a,b)=\\gcd(-a,b)=\\gcd(a,-b)$，所以不妨设 $a,b$ 都是正数。\n    \n    考虑辗转相除法的过程，有\n    \n    $$\n    \\begin{aligned}\n    a   &= q_1b   + r_1, && 0\\le r_1 < b,\\\\\n    b   &= q_2r_1 + r_2, && 0\\le r_2 < r_1,\\\\\n    r_1 &= q_3r_2 + r_3, && 0\\le r_3 < r_2,\\\\\n        & \\cdots \\\\\n    r_{n-3} &= q_{n-1}r_{n-2} + r_{n-1}, && 0\\le r_{n-1} < r_{n-2},\\\\\n    r_{n-2} &= q_nr_{n-1} + r_n,         && 0\\le r_n     < r_{n-1},\\\\\n    r_{n-1} &= q_{n+1}r_n.\n    \\end{aligned}\n    $$\n    \n    由于最大公约数是 $d$，最后一步辗转相除时，一定有 $r_n=d$。所以，倒数第二个等式可以写作\n    \n    $$\n    d = r_n = r_{n-2} - q_nr_{n-1}.\n    $$\n    \n    从倒数第三个等式中解出\n    \n    $$\n    r_{n-1} = r_{n-3} - q_{n-1}r_{n-2}\n    $$\n    \n    再代入上式，就可以消去 $r_{n-1}$：\n    \n    $$\n    \\begin{aligned}\n    d &= r_{n-2} - q_n(r_{n-3} - q_{n-1}r_{n-2}) \\\\\n    &= (1 + q_nq_{n-1})r_{n-2} - q_nr_{n-3}.\n    \\end{aligned}\n    $$\n    \n    类似地，可以逐步地消去所有 $r_{n-2},r_{n-3},\\cdots,r_2,r_1$，最终得到\n    \n    $$\n    d = xa + yb.\n    $$\n    \n    这就证明了存在 $x,y$ 使得 $ax+by=d$ 成立。由前文分析可知，这也证明了原命题。\n\n此处，关于存在性的证明是构造性的，它同时给出了该系数的一种计算方法。这一计算方法就是 [扩展欧几里得算法](./gcd.md#扩展欧几里得算法)。\n\n考虑裴蜀定理在 $\\gcd(a,b)=1$ 时的特殊情形，可以得到如下推论：\n\n???+ note \"推论\"\n    整数 $a,b$ 互素，当且仅当存在整数 $x,y$，使得 $ax+by=1$ 成立。\n\n### 多个整数的情形\n\n裴蜀定理可以推广到多个整数的情形。\n\n???+ note \"定理\"\n    设 $a_1,a_2,\\cdots,a_n$ 是不全为零的整数。那么，对于任意整数 $x_1,x_2,\\cdots,x_n$，都有 $\\gcd(a_1,a_2,\\cdots,a_n)\\mid a_1x_1+a_2x_2+\\cdots+a_nx_n$ 成立；而且，存在整数 $x_1,x_2,\\cdots,x_n$，使得 $\\gcd(a_1,a",
    "tokens": 1200,
    "chunk_order_index": 0,
    "full_doc_id": "doc-1",
    "file_path": "unknown-1"
  },
  "chunk-454c8083df7cb52e925bceeb57a0c1dc": {
    "chunk_id": "chunk-454c8083df7cb52e925bceeb57a0c1dc",
    "content": ",\\cdots,a_n$ 是不全为零的整数。那么，对于任意整数 $x_1,x_2,\\cdots,x_n$，都有 $\\gcd(a_1,a_2,\\cdots,a_n)\\mid a_1x_1+a_2x_2+\\cdots+a_nx_n$ 成立；而且，存在整数 $x_1,x_2,\\cdots,x_n$，使得 $\\gcd(a_1,a_2,\\cdots,a_n)=a_1x_1+a_2x_2+\\cdots+a_nx_n$ 成立。\n\n??? note \"证明\"\n    利用 $\\gcd(a_1,a_2,\\cdots,a_n)=\\gcd(\\gcd(a_1,a_2,\\cdots,a_{n-1}),a_n)$ 这一点，对 $n$ 进行归纳即可。\n\n### 例题\n\n???+ example \"[Codeforces 510 D. Fox And Jumping](https://codeforces.com/problemset/problem/510/D)\"\n    给出 $n\\le 300$ 张卡片，分别有 $l_i$ 和 $c_i$。在一条无限长的纸带上，你可以选择花 $c_i$ 的钱来购买卡片 $i$，从此以后可以向左或向右跳 $l_i$ 个单位任意次。问你至少花多少元钱才能够跳到纸带上全部位置。若不行，输出 $-1$。\n\n??? note \"解答\"\n    分析该问题，发现想要跳到每一个格子上，必须使得所选数 $l_{i_1}, \\cdots, l_{i_k}$ 通过数次相加或相减得出的绝对值为 $1$。也就是说，存在整数 $x_1, \\cdots, x_k$ 使得 $l_{i_1} x_1 + \\cdots + l_{i_k} x_k = 1$。由多个整数的裴蜀定理，这相当于从数组 $l_1, \\cdots, l_n$ 中选择若干个数，满足它们的最大公约数为 $1$，同时要求代价和最小。\n    \n    **解法 1**：将最小代价和看作是最短路径问题，可以用 Dijkstra 算法求解。图的顶点处存储了当前的最大公约数的取值。图的起点是 $0$，要到达的目标点是 $1$。每走一步，就从当前顶点 $x$ 出发，沿着长度为 $c_i$ 的边走到顶点 $\\gcd(x,l_i)$。这一算法的时间复杂度为 $O(n^2\\log n)$。\n    \n    **解法 2**：从数组 $l_1, \\cdots, l_n$ 选择若干个数，满足它们的最大公因数为 $1$，且代价和最小，由此可以想到 0-1 背包问题。\n    \n    设 $f_{i, j}$ 表示考虑前 $i$ 个数且最大公因数为 $j$ 的最小代价，则有转移方程：\n    \n    $$\n    f_{i, j} = \\min_{\\gcd(k, l_i) = j} f_{i - 1, k} + c_i.\n    $$\n    \n    DP 后最终的总代价即为 $f_{n, 1}$。\n    \n    如同一般的 0-1 背包问题，可以用滚动数组优化，去掉第一维。而这里 300 个数可以组成的最大公约数 $j$ 是很稀疏的，可以用哈希表储存。\n    \n    实际上，这里解法 1 建出的图便是解法 2 中动态规划的状态转移图，解法 2 相当于用动态规划求有向无环图的最短路，因此解法 1 和解法 2 是等价的。但解法 2 无需储存全图，同时 DP 的时间复杂度为 $O(n + m)$，相比 Dijkstra 算法更低，因此解法 2 在时间和空间上更优。\n\n## 一次不定方程\n\n**一次不定方程**（linear Diophantine equation）是形如\n\n$$\na_1x_1 + a_2x_2 + \\cdots + a_nx_n = b\n$$\n\n的不定方程，其中，$a_1,a_2,\\cdots,a_n$ 都是整数。本节的目标是寻找它的全体整数解。\n\n### 两个变量的情形\n\n首先考虑二元一次不定方程：\n\n$$\na_1x_1 + a_2x_2 = b.\n$$\n\n裴蜀定理指出，该方程有解，当且仅当\n\n$$\nd = \\gcd(a_1,a_2) \\mid b.\n$$\n\n接下来，假设这一条件成立。利用扩展欧几里得算法可以求出方程 $a_1x_1 + a_2x_2 = d$ 的一组整数解 $(x_1^*,x_2^*)$。由此，可以得到原方程的一组特解\n\n$$\n(x_1^\\circ,x_2^\\circ) = \\left(\\frac{b}{d}x",
    "tokens": 1200,
    "chunk_order_index": 1,
    "full_doc_id": "doc-1",
    "file_path": "unknown-1"
  },
  "chunk-82266be7a5cbeb34b4e191bdc507ad4a": {
    "chunk_id": "chunk-82266be7a5cbeb34b4e191bdc507ad4a",
    "content": ") \\mid b.\n$$\n\n接下来，假设这一条件成立。利用扩展欧几里得算法可以求出方程 $a_1x_1 + a_2x_2 = d$ 的一组整数解 $(x_1^*,x_2^*)$。由此，可以得到原方程的一组特解\n\n$$\n(x_1^\\circ,x_2^\\circ) = \\left(\\frac{b}{d}x_1^*,\\frac{b}{d}x_2^*\\right).\n$$\n\n要得到全部解，可以考虑将原方程与恒等式 $a_1x_1^\\circ+a_2x_2^\\circ = b$ 相减，就有\n\n$$\na_1(x_1 - x_1^\\circ) + a_2(x_2 - x_2^\\circ) = 0.\n$$\n\n这是一个关于 $(x_1-x_1^\\circ,x_2-x_2^\\circ)$ 的齐次一次不定方程，它有通解\n\n$$\n(x_1-x_1^\\circ,x_2-x_2^\\circ) = \\left(t\\dfrac{a_2}{d},-t\\dfrac{a_1}{d}\\right).\\quad(t\\in\\mathbf Z)\n$$\n\n因此，原方程的通解就是\n\n$$\n(x_1,x_2) = \\left(x_1^\\circ + t\\dfrac{a_2}{d},x_2^\\circ - t\\dfrac{a_1}{d}\\right).\\quad(t\\in\\mathbf Z)\n$$\n\n这是直线 $a_1x_1+a_2x_2 = b$ 上一系列等间隔分布的整点。\n\n### 多个变量的情形\n\n解决了二元的情形，多元的情形也就容易解决了。对于 $n$ 元一次不定方程\n\n$$\na_1x_1 + a_2x_2 + \\cdots + a_nx_n = b,\\quad (n>3)\n$$\n\n由裴蜀定理可知，方程有解当且仅当\n\n$$\n\\gcd(a_1,a_2,\\cdots,a_n) \\mid b.\n$$\n\n和二元的情形类似，多元一次不定方程的通解同样可以写作\n\n$$\n(x_1^\\circ,x_2^\\circ,\\cdots,x_n^\\circ) + \\sum_{k=1}^{n-1} t_k(x_1^{(k)},x_2^{(k)},\\cdots,x_n^{(k)})\n$$\n\n的形式，其中，$x^\\circ$ 为一个特解，$x^{(k)}$ 为相应的齐次方程的 $(n-1)$ 个解。\n\n要求出通解的具体形式，可以通过将 $n$ 元方程转化为 $(n-1)$ 元方程来完成。不妨设 $d_1 = \\gcd(a_1,a_2)$，那么，根据裴蜀定理，$a_1x_1+a_2x_2$ 的全体恰为 $d_1$ 的所有倍数。因此，可以首先求解 $(n-1)$ 元一次不定方程：\n\n$$\nd_1y_1 + a_3x_3 + a_4x_4 + \\cdots + a_nx_n = b.\n$$\n\n设得到的它的通解为\n\n$$\n\\begin{aligned}\ny_1 &= y_1^\\circ + \\sum_{k=2}^{n-1}t_ky_1^{(k)}, \\\\\nx_i &= x_i^\\circ + \\sum_{k=2}^{n-1}t_kx_i^{(k)},\\quad i=3,\\cdots,n.\n\\end{aligned}\n$$\n\n设 $a_1x_1+a_2x_2=d_1$ 的一组特解为 $(x_1^*,x_2^*)$，那么，根据前一节的讨论可知，关于 $x_1,x_2$ 的二元一次不定方程 $a_1x_1+a_2x_2=d_1y_1$ 的通解就是\n\n$$\nx_1 = x_1^*y_1 + t_1\\dfrac{a_2}{d_1},~x_2 = x_2^*y_1 - t_1\\dfrac{a_1}{d_1}.\n$$\n\n代入 $y_1$ 的表达式，就得到原方程的通解\n\n$$\n\\begin{aligned}\nx_1 &= x_1^*y_1^\\circ + t_1\\dfrac{a_2}{d_1} + \\sum_{k=2}^{n-1}t_kx_1^*y_1^{(k)}, \\\\\nx_2 &= x_2^*y_1^\\circ - t_1\\dfrac{a_1}{d_1} + \\sum_{k=2}^{n-1}t_kx_2^*y_1^{(k)}, \\\\\nx_i &= x_i^\\circ + \\sum_{k=2}^{n-1}t_kx_i^{(k)},\\quad i=3,\\cdots,n.\n\\end{aligned}\n$$\n\n## Frobenius 硬币问题\n\n裴蜀定理给出了一个整数可以由",
    "tokens": 1200,
    "chunk_order_index": 2,
    "full_doc_id": "doc-1",
    "file_path": "unknown-1"
  },
  "chunk-e6e938413527f029ab02344b9c0d30d6": {
    "chunk_id": "chunk-e6e938413527f029ab02344b9c0d30d6",
    "content": "1}{d_1} + \\sum_{k=2}^{n-1}t_kx_2^*y_1^{(k)}, \\\\\nx_i &= x_i^\\circ + \\sum_{k=2}^{n-1}t_kx_i^{(k)},\\quad i=3,\\cdots,n.\n\\end{aligned}\n$$\n\n## Frobenius 硬币问题\n\n裴蜀定理给出了一个整数可以由若干个整数线性表出的充分必要条件。与此紧密相关的是 **Frobenius 硬币问题**（Frobenius coin problem）：\n\n-   如果硬币共有 $a_1,a_2,\\cdots,a_n$ 等若干种整数面值，且 $\\gcd(a_1,a_2,\\cdots,a_n)=1$，那么，不能够由这些硬币组成的最大整数是多少？\n\n同样是在考察整数 $k$ 什么时候可以表示为 $a_1x_1+a_2x_2+\\cdots+a_nx_n$ 的形式，裴蜀定理中 $x_i$ 可以是任意整数，而 Frobenius 硬币问题中 $x_i$ 只能是自然数。\n\n只有一种硬币的情形是平凡的，因为只能有 $a_1=1$，所有自然数都可以由它表示。而 $n>2$ 的情形又太过复杂，所以，本节仅讨论 $n=2$ 的情形。\n\n### Sylvester 定理\n\n在 1882 年，Sylvester 完全解决了 $n = 2$ 时的 Frobenius 硬币问题：\n\n???+ note \"定理（Sylvester）\"\n    对于互素的正整数 $a_1,a_2$，不能够写作 $a_1x_1+a_2x_2~(x_1,x_2\\in\\mathbf N)$ 的最大整数是 $C = a_1a_2 - a_1 - a_2$。而且，对于所有 $k\\in\\mathbf Z$，整数 $k$ 和 $C-k$ 中有且只有一个可以写作该形式。\n\n为表述方便，称可以写作 $a_1x_1+a_2x_2~(x_1,x_2\\in\\mathbf N)$ 形式的整数为 **可表示的**。\n\n??? note \"证明一\"\n    由于 $a_1,a_2$ 互素，对于任意整数 $k$，方程 $a_1x_1+a_2x_2=k$ 一定有解，且通解为\n    \n    $$\n    (x_1,x_2) = (x_1^\\circ + ta_2, x_2^\\circ - ta_1).\\quad(t\\in\\mathbf Z)\n    $$\n    \n    取 $t$ 为 $x_2^\\circ$ 对 $a_1$ 作带余除法得到的商，那么，余数 $x_2 = x_2^\\circ-ta_1$ 位于 $0$ 和 $a_1-1$ 之间。考察此时得到的一组解 $(x_1,x_2)$。因为 $x_2$ 是它能够取到的最小非负整数值，所以 $n$ 可表示当且仅当 $x_1\\ge 0$。\n    \n    **第一步**：证明大于 $C$ 的整数都是可表示的。\n    \n    当 $k > C$ 时，有\n    \n    $$\n    a_1x_1 = k - a_2x_2 > C - a_2(a_1-1) = -a_1.\n    $$\n    \n    所以，$x_1 > -1$，也就是说，$x_1\\ge 0$。这说明，$(x_1,x_2)$ 是一组自然数解。此时，$k$ 可以写作所求形式。\n    \n    **第二步**：证明 $C$ 不可表示。进而，$C$ 是最大的不可表示的整数，且 $k$ 和 $C-k$ 并非都可表示的。\n    \n    反证法。假设 $C$ 可以表示，即存在 $x_1,x_2\\in\\mathbf N$ 使得 $a_1x_1+a_2x_2=C$ 成立。代入 $C$ 的表达式，可知\n    \n    $$\n    a_1a_2 = a_1(x_1+1) + a_2(x_2+1).\n    $$\n    \n    因此，$a_2\\mid (x_1+1)$ 且 $a_1\\mid (x_2+1)$。又因为 $x_1+1,x_2+1$ 都是正数，所以，有\n    \n    $$\n    a_1a_2 \\ge a_1a_2 + a_2a_1 = 2a_1a_2.\n    $$\n    \n    矛盾。这就说明 $C$ 不可表示。结合第一步，它也就是不可表示的最大整数。\n    \n    如果 $k$ 和 $C-k$ 都可以表示，那么，将 $k$ 和 $C-k$ 的表示中的系数相加就得到 $C$ 的表示中的系数，这与 $C$ 不可表示矛盾，故而 $k$ 和 $C-k$ 至多只有",
    "tokens": 1200,
    "chunk_order_index": 3,
    "full_doc_id": "doc-1",
    "file_path": "unknown-1"
  },
  "chunk-0ccbf9d13dff692e98c431e23e916e98": {
    "chunk_id": "chunk-0ccbf9d13dff692e98c431e23e916e98",
    "content": "_2.\n    $$\n    \n    矛盾。这就说明 $C$ 不可表示。结合第一步，它也就是不可表示的最大整数。\n    \n    如果 $k$ 和 $C-k$ 都可以表示，那么，将 $k$ 和 $C-k$ 的表示中的系数相加就得到 $C$ 的表示中的系数，这与 $C$ 不可表示矛盾，故而 $k$ 和 $C-k$ 至多只有一个可以表示。\n    \n    **第三步**：证明如果 $k$ 不可表示，那么 $C-k$ 一定是可表示的。\n    \n    设 $(x_1,x_2)$ 是前文所设的方程 $a_1x_1+a_2x_2=k$ 的整数解。那么，前文已经说明 $k$ 不可表示，就等价于 $x_1<0$。因此，有\n    \n    $$\n    C - k = a_1a_2 - a_1 - a_2 - a_1x_1 - a_2x_2 = a_1(-1-x_1) + a_2(a_1-1-x_2).\n    $$\n    \n    其中，$-1-x_1$ 和 $a_1-1-x_2$ 都是非负整数，所以，$C-k$ 可以表示。\n\n??? note \"证明二\"\n    此处仅证明 $C=a_1a_2-a_1-a_2$ 是最大的不可表示的自然数，其余部分的证明类似证明一。\n    \n    考虑模 $a_2$ 意义下，每个剩余系中最小的可表示的自然数。因为同一个剩余系中的不同自然数可以通过加减若干个 $a_2$ 互相转化，所以，在讨论最小可表示数时，只需要考虑加减 $a_1$ 的可能性就可以了。由于 $a_1$ 和 $a_2$ 互素，所以，每个剩余系中最小的可表示的自然数恰好就是 $a_1$ 的倍数\n    \n    $$\n    0,~a_1,~2a_1,~\\cdots,~(a_2-1)a_1.\n    $$\n    \n    因此，最大的不可表示数为\n    \n    $$\n    \\max_{0\\le i < a_2} ia_1 - a_2 = (a_2-1)a_1 - a_2 = C.\n    $$\n\n### 几何意义\n\n将方程 $a_1x_1 + a_2x_2 = k$ 看作是一条直线。那么，$k$ 可表示，当且仅当这条直线在第一象限（包括坐标轴）内通过一个整点。当 $k < ab$ 时，这条直线在第一象限至多只能通过一个整点。因此，对于 $0\\le k < ab$，整数 $k$ 可以表示，当且仅当 $k$ 在第一象限通过恰好一个整点。\n\n因此，小于等于 $k < ab$ 且可以表示的自然数的数量，恰好等于第一象限内直线 $a_1x_1 + a_2x_2 = k$ 下的整点个数（包含边界上的点）。这一数量就等于\n\n$$\n\\sum_{i=0}^{\\lfloor k / a_1 \\rfloor} \\left\\lfloor\\dfrac{k-ia_1}{a_2}\\right\\rfloor.\n$$\n\n这是经典的直线下整点问题，可以用 [类欧几里得算法](./euclidean.md#类欧几里得算法) 在 $O(\\log\\min\\{a_1,a_2,k\\})$ 时间求解。\n\n### 习题\n\n-   [Luogu P3951 NOIP2017 提高组 小凯的疑惑/蓝桥杯 2013 省 买不到的数目](https://www.luogu.com.cn/problem/P3951)",
    "tokens": 893,
    "chunk_order_index": 4,
    "full_doc_id": "doc-1",
    "file_path": "unknown-1"
  }
}