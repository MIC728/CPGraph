{
  "chunk-15497b49d58d47b6bf377a00c8183b65": {
    "chunk_id": "chunk-15497b49d58d47b6bf377a00c8183b65",
    "content": "位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。\n\n基本的位运算共 $6$ 种，分别为按位与、按位或、按位异或、按位取反、左移和右移。\n\n为了方便叙述，下文中省略「按位」。\n\n## 与、或、异或\n\n这三者都是两数间的运算，因此在这里一起讲解。\n\n它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。\n\n| 运算 | 运算符 | 数学符号表示                   |                 解释                  |\n| ---- | :----: | ------------------------------ | :-----------------------------------: |\n| 与   |  `&`   | $\\&$、$\\operatorname{and}$     |   只有两个对应位都为 $1$ 时才为 $1$   |\n| 或   |  `|`   | $\\mid$、$\\operatorname{or}$    | 只要两个对应位中有一个 $1$ 时就为 $1$ |\n| 异或 |  `^`   | $\\oplus$、$\\operatorname{xor}$ |     只有两个对应位不同时才为 $1$      |\n\n注意区分逻辑与（对应的数学符号为 $\\wedge$）和按位与、逻辑或（$\\vee$）和按位或的区别。网络中的资料中使用的符号多有不规范之处，以上下文为准。\n\n异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 $a \\oplus b \\oplus b = a$ 。\n\n举例：\n\n$$\n\\begin{aligned}\n5 &=(101)_2\\\\\n6 &=(110)_2\\\\\n5\\operatorname\\&6 &=(100)_2 =\\ 4\\\\\n5\\operatorname|6 &=(111)_2 =\\ 7\\\\\n5\\oplus6 &=(011)_2 =\\ 3\\\\\n\\end{aligned}\n$$\n\n## 取反\n\n取反是对一个数 $num$ 进行的位运算，即单目运算。\n\n取反暂无默认的数学符号表示，其对应的运算符为 `~`。它的作用是把 $num$ 的二进制补码中的 $0$ 和 $1$ 全部取反（$0$ 变为 $1$，$1$ 变为 $0$）。有符号整数的符号位在 `~` 运算中同样会取反。\n\n补码：在二进制表示下，正数和 $0$ 的补码为其本身，负数的补码是将其对应正数按位取反后加一。\n\n举例（有符号整数）：\n\n$$\n\\begin{aligned}\n5&=(00000101)_2\\\\\n\\text{~}5&=(11111010)_2=-6\\\\\n-5\\text{ 的补码}&=(11111011)_2\\\\\n\\text{~}(-5)&=(00000100)_2=4\n\\end{aligned}\n$$\n\n## 左移和右移\n\n`num << i` 表示将 $num$ 的二进制表示向左移动 $i$ 位所得的值。\n\n`num >> i` 表示将 $num$ 的二进制表示向右移动 $i$ 位所得的值。\n\n举例：\n\n$$\n\\begin{aligned}\n11&=(00001011)_2\\\\\n11<<3&=(01011000)_2=88\\\\\n11>>2&=(00000010)_2=2\n\\end{aligned}\n$$\n\n移位运算中如果出现如下情况，则其行为未定义：\n\n1. 右操作数（即移位数）为负值；\n2. 右操作数大于等于左操作数的位数；\n\n例如，对于 `int` 类型的变量 `a` ， `a<<-1` 和 `a<<32` 都是未定义的。\n\n对于左移操作，需要确保移位后的结果能被原数的类型容纳，否则行为也是未定义的。[^note1]对一个负数执行左移操作也未定义。[^note2]\n\n对于右移操作，右侧多余的位将会被舍弃，而左侧较为复杂：对于无符号数，会在左侧补 $0$；而对于有符号数，则会用最高位的数（其实就是符号位，非负数为 $0$，负数为 $1$）补齐。[^note3]\n\n## 复合赋值位运算符\n\n和 `+=` , `-=` 等运算符类似，位运算也有复合赋值运算符： `&=` , `|=` , `^=` , `<<=` , `>>=` 。（取反是单目运算，所以没有。）\n\n## 关于优先级\n\n位运算的优先级低于算术运算符（除了取反），而按位与、按位或及异或低于比较运算符（详见 [C++ 运算符优先级总表](../lang/op.md#c-运算符优先级总表)），所以使用时需多加注意，在必要时添加括号。\n\n## 位运算的",
    "tokens": 1200,
    "chunk_order_index": 0,
    "full_doc_id": "doc-0",
    "file_path": "unknown-0"
  },
  "chunk-aacbc4e2befea773df472f607efb7bae": {
    "chunk_id": "chunk-aacbc4e2befea773df472f607efb7bae",
    "content": "运算符： `&=` , `|=` , `^=` , `<<=` , `>>=` 。（取反是单目运算，所以没有。）\n\n## 关于优先级\n\n位运算的优先级低于算术运算符（除了取反），而按位与、按位或及异或低于比较运算符（详见 [C++ 运算符优先级总表](../lang/op.md#c-运算符优先级总表)），所以使用时需多加注意，在必要时添加括号。\n\n## 位运算的应用\n\n位运算一般有三种作用：\n\n1. 高效地进行某些运算，代替其它低效的方式。\n\n2. 表示集合（常用于 [状压 DP](../dp/state.md)）。\n\n3. 题目本来就要求进行位运算。\n\n需要注意的是，用位运算代替其它运算方式（即第一种应用）在很多时候并不能带来太大的优化，反而会使代码变得复杂，使用时需要斟酌。（但像「乘 2 的非负整数次幂」和「除以 2 的非负整数次幂」就最好使用位运算，因为此时使用位运算可以优化复杂度。）\n\n### 有关 2 的幂的应用\n\n由于位运算针对的是变量的二进制位，因此可以推广出许多与 2 的整数次幂有关的应用。\n\n将一个数乘（除） 2 的非负整数次幂：\n\n=== \"C++\"\n    ```cpp\n    int mulPowerOfTwo(int n, int m) {  // 计算 n*(2^m)\n      return n << m;\n    }\n    int divPowerOfTwo(int n, int m) {  // 计算 n/(2^m)\n      return n >> m;\n    }\n    ```\n\n=== \"Python\"\n    ```python\n    def mulPowerOfTwo(n, m): # 计算 n*(2^m)\n        return n << m\n    def divPowerOfTwo(n, m): # 计算 n/(2^m)\n        return n >> m\n    ```\n\n!!! warning\n    我们平常写的除法是向 $0$ 取整，而这里的右移是向下取整（注意这里的区别），即当数大于等于 $0$ 时两种方法等价，当数小于 $0$ 时会有区别，如： `-1 / 2` 的值为 $0$ ，而 `-1 >> 1` 的值为 $-1$ 。\n\n### 取绝对值\n\n在某些机器上，效率比 `n > 0 ? n : -n` 高。\n\n=== \"C++\"\n    ```cpp\n    int Abs(int n) {\n      return (n ^ (n >> 31)) - (n >> 31);\n      /* n>>31 取得 n 的符号，若 n 为正数，n>>31 等于 0，若 n 为负数，n>>31 等于 -1\n        若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)\n        需要计算 n 和 -1 的补码，然后进行异或运算，\n        结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值 */\n    }\n    ```\n\n=== \"Python\"\n    ```python\n    def Abs(n):\n        return (n ^ (n >> 31)) - (n >> 31)\n        \"\"\"\n        n>>31 取得 n 的符号，若 n 为正数，n>>31 等于 0，若 n 为负数，n>>31 等于 -1\n        若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)\n        需要计算 n 和 -1 的补码，然后进行异或运算，\n        结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值\n        \"\"\"\n    \n    ```\n\n### 取两个数的最大/最小值\n\n在某些机器上，效率比 `a > b ? a : b` 高。\n\n=== \"C++\"\n    ```cpp\n    // 如果 a >= b, (a - b) >> 31 为 0，否则为 -1\n    int max(int a, int b) { return (b & ((a - b) >> 31)) | (a & (~(a - b) >> 31)); }\n    int min(int a, int b) { return (a & ((a - b) >> 31)) | (b & (~(a - b) >> 31)); }\n    ```\n\n=== \"Python\"\n    ```python\n    # 如果 a >= b, (a - b) >> 31 为 0，否则为 -1\n    def max(a, b):\n        return b & ((a - b) >> 31) | a & (~(a - b) >> 31)\n    def min(a, b):\n        return a & ((a - b) >> 31) | b & (~(a - b) >> 31)\n    ```\n\n### 判断两非零数符号是否相同\n\n=== \"C++\"\n    ```cpp\n    bool isSameSign(int x, int y) {  // 有 0 的情况例外\n      return (x ^ y) >= 0;",
    "tokens": 1200,
    "chunk_order_index": 1,
    "full_doc_id": "doc-0",
    "file_path": "unknown-0"
  },
  "chunk-58c788daea81b4c9ebf3eb968366df19": {
    "chunk_id": "chunk-58c788daea81b4c9ebf3eb968366df19",
    "content": "为 -1\n    def max(a, b):\n        return b & ((a - b) >> 31) | a & (~(a - b) >> 31)\n    def min(a, b):\n        return a & ((a - b) >> 31) | b & (~(a - b) >> 31)\n    ```\n\n### 判断两非零数符号是否相同\n\n=== \"C++\"\n    ```cpp\n    bool isSameSign(int x, int y) {  // 有 0 的情况例外\n      return (x ^ y) >= 0;\n    }\n    ```\n\n=== \"Python\"\n    ```python\n    # 有 0 的情况例外\n    def isSameSign(x, y):\n        return (x ^ y) >= 0\n    ```\n\n### 交换两个数\n\n???+note \"该方法具有局限性\"\n    这种方式只能用来交换两个整数，使用范围有限。\n    \n    对于一般情况下的交换操作，推荐直接调用 `algorithm` 库中的 `std::swap` 函数。\n\n```cpp\nvoid swap(int &a, int &b) { a ^= b ^= a ^= b; }\n```\n\n### 操作一个数的二进制位\n\n获取一个数二进制的某一位：\n\n=== \"C++\"\n    ```cpp\n    // 获取 a 的第 b 位，最低位编号为 0\n    int getBit(int a, int b) { return (a >> b) & 1; }\n    ```\n\n=== \"Python\"\n    ```python\n    # 获取 a 的第 b 位，最低位编号为 0\n    def getBit(a, b):\n        return (a >> b) & 1\n    ```\n\n将一个数二进制的某一位设置为 $0$：\n\n=== \"C++\"\n    ```cpp\n    // 将 a 的第 b 位设置为 0 ，最低位编号为 0\n    int unsetBit(int a, int b) { return a & ~(1 << b); }\n    ```\n\n=== \"Python\"\n    ```python\n    # 将 a 的第 b 位设置为 0 ，最低位编号为 0\n    def unsetBit(a, b):\n        return a & ~(1 << b)\n    ```\n\n将一个数二进制的某一位设置为 $1$：\n\n=== \"C++\"\n    ```cpp\n    // 将 a 的第 b 位设置为 1 ，最低位编号为 0\n    int setBit(int a, int b) { return a | (1 << b); }\n    ```\n\n=== \"Python\"\n    ```python\n    # 将 a 的第 b 位设置为 1 ，最低位编号为 0\n    def setBit(a, b):\n        return a | (1 << b)\n    ```\n\n将一个数二进制的某一位取反：\n\n=== \"C++\"\n    ```cpp\n    // 将 a 的第 b 位取反 ，最低位编号为 0\n    int flapBit(int a, int b) { return a ^ (1 << b); }\n    ```\n\n=== \"Python\"\n    ```python\n    # 将 a 的第 b 位取反 ，最低位编号为 0\n    def flapBit(a, b):\n        return a ^ (1 << b)\n    ```\n\n这些操作相当于将一个 $32$ 位整型变量当作一个长度为 $32$ 的布尔数组。\n\n## 汉明权重\n\n汉明权重是一串符号中不同于（定义在其所使用的字符集上的）零符号（zero-symbol）的个数。对于一个二进制数，它的汉明权重就等于它 $1$ 的个数（即 `popcount`）。\n\n求一个数的汉明权重可以循环求解：我们不断地去掉这个数在二进制下的最后一位（即右移 $1$ 位），维护一个答案变量，在除的过程中根据最低位是否为 $1$ 更新答案。\n\n代码如下：\n\n```cpp\n// 求 x 的汉明权重\nint popcount(int x) {\n    int cnt = 0;\n    while (x) {\n        cnt += x & 1;\n        x >>= 1;\n    }\n    return cnt;\n}\n```\n\n求一个数的汉明权重还可以使用 `lowbit` 操作：我们将这个数不断地减去它的 `lowbit`[^note4]，直到这个数变为 $0$。\n\n代码如下：\n\n```cpp\n// 求 x 的汉明权重\nint popcount(int x) {\n    int cnt = 0;\n    while (x) {\n        cnt++;\n        x -= x & -x;\n    }\n    return cnt;\n}\n```\n\n### 构造汉明权重递增的排列\n\n在 [状压 DP](../dp/state.md) 中，按照 popcount 递增的顺序枚举有时可以避免重复枚举状态。这是构造汉明权重递增的排列的一大作用。\n\n下面我们来具体探究如何在 $O(n)$ 时间内构造汉明权重递增的排列。\n\n我们知道，一个汉明权重为 $n$ 的最小的整数为 $2^n-1$。只要可以在常数时间构造出一个整数汉明权重相等的后继，我们就可以通过枚举汉明权重，从 $2^n-1$ 开始不断寻找下一个数的方式，在 $O(n)$ 时间内构造出 $0\\sim",
    "tokens": 1200,
    "chunk_order_index": 2,
    "full_doc_id": "doc-0",
    "file_path": "unknown-0"
  },
  "chunk-c80ad579a04544346fde1fcb44b95b8e": {
    "chunk_id": "chunk-c80ad579a04544346fde1fcb44b95b8e",
    "content": "。这是构造汉明权重递增的排列的一大作用。\n\n下面我们来具体探究如何在 $O(n)$ 时间内构造汉明权重递增的排列。\n\n我们知道，一个汉明权重为 $n$ 的最小的整数为 $2^n-1$。只要可以在常数时间构造出一个整数汉明权重相等的后继，我们就可以通过枚举汉明权重，从 $2^n-1$ 开始不断寻找下一个数的方式，在 $O(n)$ 时间内构造出 $0\\sim n$ 的符合要求的排列。\n\n而找出一个数 $x$ 汉明权重相等的后继有这样的思路，以 $(10110)_2$ 为例：\n\n- 把 $(10110)_2$ 最右边的 $1$ 向左移动，如果不能移动，移动它左边的 $1$，以此类推，得到 $(11010)_2$。\n\n- 把得到的 $(11010)_2$ 最后移动的 $1$ 原先的位置一直到最低位的所有 $1$ 都移到最右边。这里最后移动的 $1$ 原来在第三位，所以最后三位 $010$ 要变成 $001$，得到 $(11001)_2$。\n\n这个过程可以用位运算优化：\n\n```cpp\nint t = x + (x & -x);\nx = t | ((((t&-t)/(x&-x))>>1)-1);\n```\n\n- 第一个步骤中，我们把数 $x$ 加上它的 `lowbit`，在二进制表示下，就相当于把 $x$ 最右边的连续一段 $1$ 换成它左边的一个 $1$。如刚才提到的二进制数 $(10110)_2$，它在加上它的 `lowbit` 后是 $(11000)_2$。这其实得到了我们答案的前半部分。\n- 我们接下来要把答案后面的 $1$ 补齐，$t$  的 `lowbit` 是 $x$ 最右边连续一段 $1$ 最左边的 $1$ 移动后的位置，而 $x$ 的 `lowbit` 则是 $x$ 最右边连续一段 $1$ 最右边的位置。还是以 $(10110)_2$ 为例，$t = (11000)_2$，$\\operatorname{lowbit}(t) = (01000)_2$，$\\operatorname{lowbit}(x)=(00010)_2$。\n- 接下来的除法操作是这种位运算中最难理解的部分，但也是最关键的部分。我们设**原数**最右边连续一段 $1$ 最高位的 $1$ 在第 $r$  位上（位数从 $0$ 开始），最低位的 $1$ 在第 $l$ 位，$t$ 的 `lowbit` 等于 `1 << (r+1)` ，$x$ 的 `lowbit` 等于 `1 << l`， `(((t&-t)/(x&-x))>>1)` 得到的，就是 `(1<<(r+1))/(1<<l)/2 = (1<<r)/(1<<l) = 1<<(r-l)` ，在二进制表示下就是 $1$ 后面跟上 $r-l$ 个零，零的个数正好等于连续 $1$ 的个数减去 $1$ 。举我们刚才的数为例，$\\frac{\\operatorname{lowbit(t)/2}}{\\operatorname{lowbit(x)}} = \\frac{(00100)_2}{(00010)_2} = (00010)_2$ 。把这个数减去 $1$ 得到的就是我们要补全的低位，或上原来的数就可以得到答案。\n\n所以枚举 $0\\sim n$ 按汉明权重递增的排列的完整代码为：\n\n```cpp\nfor (int i = 0; (1<<i)-1 <= n; i++) {\n    for (int x = (1<<i)-1, t; x <= n; t = x+(x&-x), x = x ? (t|((((t&-t)/(x&-x))>>1)-1)) : (n+1)) {\n        // 写下需要完成的操作\n    }\n}\n```\n\n其中要注意 $0$ 的特判，因为 $0$ 没有相同汉明权重的后继。\n\n## 内建函数\n\nGCC 中还有一些用于位运算的内建函数：\n\n1.  `int __builtin_ffs(int x)` ：返回 $x$ 的二进制末尾最后一个 $1$ 的位置，位置的编号从 $1$ 开始（最低位编号为 $1$ ）。当 $x$ 为 $0$ 时返回 $0$ 。\n\n2.  `int __builtin_clz(unsigned int x)` ：返回 $x$ 的二进制的前导 $0$ 的个数。当 $x$ 为 $0$ 时，结果未定义。\n\n3.  `int __builtin_ctz(unsigned int x)` ：返回 $x$ 的二进制末尾连续 $0$ 的个数。当 $x$ 为 $0$ 时，结果未定义。\n\n4.  `int __builtin_clrsb(int x)` ：当 $x$ 的符号位为 $0$",
    "tokens": 1200,
    "chunk_order_index": 3,
    "full_doc_id": "doc-0",
    "file_path": "unknown-0"
  },
  "chunk-a711a995857175e06675ee1b6ae5be1a": {
    "chunk_id": "chunk-a711a995857175e06675ee1b6ae5be1a",
    "content": "x$ 为 $0$ 时返回 $0$ 。\n\n2.  `int __builtin_clz(unsigned int x)` ：返回 $x$ 的二进制的前导 $0$ 的个数。当 $x$ 为 $0$ 时，结果未定义。\n\n3.  `int __builtin_ctz(unsigned int x)` ：返回 $x$ 的二进制末尾连续 $0$ 的个数。当 $x$ 为 $0$ 时，结果未定义。\n\n4.  `int __builtin_clrsb(int x)` ：当 $x$ 的符号位为 $0$ 时返回 $x$ 的二进制的前导 $0$ 的个数减一，否则返回 $x$ 的二进制的前导 $1$ 的个数减一。\n\n5.  `int __builtin_popcount(unsigned int x)` ：返回 $x$ 的二进制中 $1$ 的个数。\n\n6.  `int __builtin_parity(unsigned int x)` ：判断 $x$ 的二进制中 $1$ 的个数的奇偶性。\n\n这些函数都可以在函数名末尾添加 `l` 或 `ll` （如 `__builtin_popcountll` ）来使参数类型变为 ( `unsigned` ) `long` 或 ( `unsigned` ) `long long` （返回值仍然是 `int` 类型）。\n例如，我们有时候希望求出一个数以二为底的对数，如果不考虑 `0` 的特殊情况，就相当于这个数二进制的位数 `-1` ，而一个数 `n` 的二进制表示的位数可以使用 `32-__builtin_clz(n)` 表示，因此 `31-__builtin_clz(n)` 就可以求出 `n` 以二为底的对数。\n\n由于这些函数是内建函数，经过了编译器的高度优化，运行速度十分快（有些甚至只需要一条指令）。\n\n## 更多位数\n\n如果需要操作的集合非常大，可以使用 [bitset](../lang/csl/bitset.md) 。\n\n## 题目推荐\n\n [Luogu P1225 黑白棋游戏](https://www.luogu.com.cn/problem/P1225) \n\n## 参考资料与注释\n\n1. 位运算技巧： <https://graphics.stanford.edu/~seander/bithacks.html> \n2. Other Builtins of GCC： <https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html> \n\n[^note1]: 适用于 C++14 以前的标准。在 C++14 和 C++17 标准中，若原值为带符号类型，且移位后的结果能被原类型的无符号版本容纳，则将该结果 [转换](../lang/var.md#类型转换) 为相应的带符号值，否则行为未定义。在 C++20 标准中，规定了无论是带符号数还是无符号数，左移均直接舍弃移出结果类型的位。\n\n[^note2]: 适用于 C++20 以前的标准。\n\n[^note3]: 这种右移方式称为算术右移。在 C++20 以前的标准中，并没有规定带符号数右移运算的实现方式，大多数平台均采用算术右移。在 C++20 标准中，规定了带符号数右移运算是算术右移。\n\n[^note4]: 一个数二进制表示从低往高的第一个 $1$ 连同后面的零，如 $(1010)_2$ 的 `lowbit` 是 $(0010)_2$，详见 [树状数组](../ds/fenwick.md)。",
    "tokens": 801,
    "chunk_order_index": 4,
    "full_doc_id": "doc-0",
    "file_path": "unknown-0"
  }
}